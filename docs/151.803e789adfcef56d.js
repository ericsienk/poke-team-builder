(()=>{"use strict";addEventListener("message",({data:{team:I,pokemon:r,iterations:s=1e4,banList:i=[]}})=>{const p=new w(r),h=p.teamBuilder();I.forEach(c=>h.pick(c)),postMessage(p.createTeam(s,h.build(),i))});const n=.5,d=["hp","atk","def","spa","spd","spe"];class w{constructor(r){this.pokemon=r,this.STATS=d,this.pkmnNameMap=this.pokemon.reduce((s,i)=>(s[i.name]=i,s),{}),this.typeIndex={Bug:0,Dark:1,Dragon:2,Electric:3,Fairy:4,Fighting:5,Fire:6,Flying:7,Ghost:8,Grass:9,Ground:10,Ice:11,Normal:12,Poison:13,Psychic:14,Rock:15,Steel:16,Water:17},this.typeMatrix=[[1,2,1,1,n,n,n,n,n,2,1,1,1,n,2,1,n,1],[1,n,1,1,n,n,1,1,2,1,1,1,1,1,2,1,1,1],[1,1,2,1,0,1,1,1,1,1,1,1,1,1,1,1,n,1],[1,1,n,n,1,1,1,2,1,n,n,1,1,1,1,1,1,2],[1,2,2,1,1,2,n,1,1,1,1,1,1,n,1,1,n,1],[n,2,1,1,n,1,1,n,0,1,1,2,2,n,n,2,2,1],[2,1,n,1,1,1,n,1,1,2,1,2,1,1,1,n,2,n],[2,1,1,n,1,1,1,2,1,1,1,1,1,1,1,n,n,1],[1,n,1,1,1,1,1,1,2,1,1,1,0,1,2,1,1,1],[n,1,n,1,1,1,n,n,1,n,2,1,1,n,1,2,n,2],[n,1,1,2,1,1,2,n,1,n,1,1,1,2,1,2,2,1],[1,1,2,1,1,1,n,2,1,2,2,n,1,1,1,1,n,n],[1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,n,n,1],[1,1,1,1,2,1,1,1,n,2,n,1,1,n,1,n,0,1],[1,n,1,1,1,2,1,1,1,1,1,1,1,1,2,n,n,1],[2,1,1,1,1,n,2,2,1,1,n,2,1,1,1,1,n,1],[1,1,1,n,2,1,n,1,1,1,1,2,1,1,1,2,n,n],[1,1,n,1,1,1,2,1,1,n,2,1,1,1,1,2,1,n]]}teamBuilder(r=[]){const s=this.pkmnNameMap,i={team:[],pick:function(p){return this.team.push(s[p]),this},build:function(){return this.team},size:function(){return this.team.length}};for(let p of r)i.pick(p);return i}_avgStats(r,s){r.pk.push(s);for(let i of d)r[i]=(r[i]+s[i])/2;s.total=this._getTotalStats(s),r.total=(r.total+s.total)/2}_getPercentile(r,s){const i={};for(let p of d){const h=s.map(c=>c[p]).sort().reverse();i[p]=Math.round(100/s.length*(h.lastIndexOf(r[p])+1))}return i}_initTypeStat(r){return{pk:[],types:r,hp:0,atk:0,def:0,spa:0,spd:0,spe:0,total:0,std:{hp:0,atk:0,def:0,spa:0,spd:0,spe:0,total:0},count:0}}_processTypingStat(r,s,i){let p=r[s];p||(r[s]=p=this._initTypeStat(s)),p.count++,this._avgStats(p,i)}_typesMapToArray(r){return Object.values(r).sort((s,i)=>s.count<i.count?1:s.count>i.count?-1:0).map(s=>(s.pk.sort((i,p)=>i.total<p.total?1:i.total>p.total?-1:0),s))}_getTotalStats(r){return d.reduce((s,i)=>s+r[i],0)}analyzeTypes(r={evolved:!0,sort:["totalStats"],statsLimit:601}){const s={},i={},h=[];this.pokemon.forEach(u=>{const t=u.types.sort().join("/");this._processTypingStat(s,t,u),u.types.forEach(a=>this._processTypingStat(i,a,u)),h.push(u)});const c=this._typesMapToArray(s),y=this._typesMapToArray(i);return{uniqueTypes:c,unqiueTypesMap:s,strongestUniqueType:[...d,"total"].reduce((u,t)=>(u[t]=c.reduce((a,l)=>l[t]>(a[t]||0)?l:a,{}),u),{}),types:y,typesMap:i,ubers:[].sort((u,t)=>u.total-t.total),strongestType:[...d,"total"].reduce((u,t)=>(u[t]=y.reduce((a,l)=>l[t]>(a[t]||0)?l:a,{}),u),{}),pk:h}}getSweeperScore(r){return Math.max(r.spa,r.atk)+Math.min(r.spe,115)}getTankScore(r){return(r.spd+r.def)/2+r.hp}getTypeAdvantages(r,s){const i=[],p=[],h=[],c=[];for(let y of s){for(let u of y){let t=1;const l=this.typeMatrix[this.typeIndex[u]];for(let T of r.types)t*=l[this.typeIndex[T]];t>1&&(i.push(y.join("/")),t=1),t<1&&(p.push(y.join("/")),t=1)}for(let u of r.types){let t=1;const l=this.typeMatrix[this.typeIndex[u]];for(let T of y)t*=l[this.typeIndex[T]];t>1&&(h.push(y.join("/")),t=1),t<1&&(c.push(y.join("/")),t=1)}}return{resistantTo:p,weakTo:i,strongTo:h,notEffectiveTo:c}}createTeam(r,s,i=[],p=6){const h=r,c=s?s.map(t=>t.name):[];console.log(c),console.log(h);const y=this.analyzeTypes();let u=null;for(;r>0;){const t=this.teamBuilder(c);for(;t.size()<p;){const f=y.pk[Math.floor(Math.random()*y.pk.length)].name;i.includes(f)||t.pick(f)}let a=this.analyzeTeam(t.build(),y);const l=a.weakTo.length,T=a.okayTo.slice(0,15).reduce((f,A)=>f+A.total,0);a.scoring=10*l+1.5*T-(a.strongTo.length+2*a.sweeperScore/20),(!u||a.scoring<u.scoring)&&(u=a,console.log(`\n****WINNER**** [${a.scoring}] ${a.team.map(f=>f.name).join()}`),postMessage(Object.assign(Object.assign({},u),{currentInteration:h-r}))),r--}return Object.assign(Object.assign({},u),{done:!0})}analyzeTeam(r,s){s=s||this.analyzeTypes();let i=0,p=0;const h=r.map(t=>{let a=Object.assign(Object.assign({pokemon:t},this.getTypeAdvantages(t,s.uniqueTypes.map(l=>l.types.split("/")))),{sweeperScore:this.getSweeperScore(t),tankScore:this.getTankScore(t)});return i+=a.sweeperScore,p+=a.tankScore,a}),c={},y={};return h.forEach(t=>{t.weakTo.forEach(a=>{c[a]=c[a]||{count:0,coveredCount:0},c[a].count++}),t.strongTo.forEach(a=>{y[a]=y[a]||{count:0},y[a].count++})}),Object.keys(y).forEach(t=>{c[t]&&c[t].coveredCount++}),{sweeperScore:i,tankScore:p,team:r.map(t=>{let a=s.unqiueTypesMap[t.types.join("/")].pk;return t.alternatives=a.filter(l=>l.name!=t.name).map(l=>l.name).join(", "),t.percentile=Object.assign({},t.types.map(l=>({type:l,percentile:this._getPercentile(t,s.typesMap[l].pk)})).reduce((l,T)=>(l[T.type]=T.percentile,l),{})),t.types.length>1&&(t.percentile[t.types.join("/")]=this._getPercentile(t,s.unqiueTypesMap[t.types.join("/")].pk)),t}),weakTo:Object.keys(c).filter(t=>0===c[t].coveredCount),strongTo:Object.keys(c).map(t=>c[t].count-c[t].coveredCount<1&&c[t].coveredCount>0&&t).filter(t=>t),okayTo:Object.keys(c).map(t=>{if(c[t].count-c[t].coveredCount>=1&&c[t].coveredCount>0)return Object.assign({type:t,total:c[t].count-c[t].coveredCount},c[t])}).filter(t=>t).sort((t,a)=>t.total-a.total).reverse()}}}})();